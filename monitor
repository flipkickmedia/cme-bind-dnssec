#!/usr/bin/env bash
# dnssec-monitor.sh
# monitor named log output for CDS published string
# run update.sh with domain
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

if [[ -f "${DIR}/lib.sh" ]]; then
  # shellcheck disable=SC1091
  echo "...loading lib ${DIR}/lib.sh"
  . "${DIR}/lib.sh"
fi

# shellcheck disable=SC2153
if [[ -f "/etc/cme/dnssec-monitor.env" ]]; then
  echo "...loading /etc/cme/dnssec-monitor.env"
  # shellcheck disable=SC1091
  . "/etc/cme/dnssec-monitor.env"
fi

files="/var/log/named/named.run"
empty_ds_regex='zone (.*)/IN/(.*) \('

# clean ds process files which stop repeated additions via nsupdate for the same domain within a given time period
if [[ $1 == '--clean' ]]; then
  log "cme-dnssec-monitor (clean) starting $$"
  log "monitor running on $$ to clean dsprocess locks"

  if [[ -f "${DIR}/lib.sh" ]]; then
    # shellcheck disable=SC1091
    echo "...loading lib ${DIR}/lib.sh"
    . "${DIR}/lib.sh"
  fi
  # shellcheck disable=SC2153
  if [[ -f "/etc/cme/dnssec-monitor.env" ]]; then
    echo "...loading /etc/cme/dnssec-monitor.env"
    # shellcheck disable=SC1091
    . "/etc/cme/dnssec-monitor.env"
  fi
  readarray -td: views < <(printf '%s' "$VIEWS")

  function trap_exit() {
    log "terminating dsprocess monitor on PID:$$"
    exit 0
  }

  trap "trap_exit" SIGINT SIGHUP 15

  shopt -s extglob
  declare -i count_dsprocess_locks=0
  # manage the ds process logs by dleteing those older than
  while (true); do
    # log "looping ds clean"
    # shellcheck disable=SC2068
    for view in ${views[@]}; do
      for dsprocess in "${DSPROCESS_PATH}/${view}/*.dsprocess"; do
        # log "checking dsprocess $dsprocess"
        if [ ! -f "$dsprocess" ]; then
          continue
        fi
        if [[ $(date -r "$dsprocess" "+%s") -lt $(($(date +%s) - 30)) ]]; then
          locked_domain=$(basename "$dsprocess")
          rm "$dsprocess"
          count_dsprocess_locks=$((count_dsprocess_locks + 1))
        fi
      done
    done
    sleep 5
  done
  log "dsprocess locks ($count_dsprocess_locks) removed"
fi

if [[ $1 == '--init' ]]; then
  log "monitor (initalise keys) running on $$"

  if [[ -f "${DIR}/lib.sh" ]]; then
    # shellcheck disable=SC1091
    echo "...loading lib ${DIR}/lib.sh"
    . "${DIR}/lib.sh"
  fi

  # shellcheck disable=SC2153
  if [[ -f "/etc/cme/dnssec-monitor.env" ]]; then
    echo "...loading /etc/cme/dnssec-monitor.env"
    # shellcheck disable=SC1091
    . "/etc/cme/dnssec-monitor.env"
  fi
  readarray -td: views < <(printf '%s' "$VIEWS")

  function trap_exit() {
    log "terminating initalisation of DS keys"
    exit 1
  }

  declare domain
  declare view
  declare ip_addr
  declare ns_server
  declare ttl
  declare key_id
  declare key_path
  declare dsprocess_path
  declare domain_key
  declare domain_conf
  declare domain_parent
  declare record
  declare depth
  declare iface
  declare iface_name
  declare key_name
  declare key
  declare found_key=false

  # shellcheck disable=SC2068
  for view in "${views[@]}"; do
    echo view check
    config_init

    declare dsprocess_path="${DSPROCESS_PATH}"
    declare key_path
    for file in /var/cache/bind/keys/"${view}"/*.state; do
      key_path_prefix="${key_path}/${view}/K"
      key="${file//$key_path_prefix/}"
      key="${key//\.state/}"
      readarray -td '.' domain_parts < <(printf "%s" "$key")
      readarray -td '' array_reversed < <(
        ((${#domain_parts[@]})) && printf '%s\0' "${domain_parts[@]}" | tac -s ''
      )
      unset 'array_reversed[0]'
      readarray -td '' domain_parts < <(
        ((${#array_reversed[@]})) && printf '%s\0' "${array_reversed[@]}" | tac -s ''
      )

      if grep -q "KSK: yes" "$file"; then
        if ! grep -q "Successor:" "$file"; then
          id=$(echo "$f" | grep -Po '\d+' | tail -n 1)
          found_key=true
          #dev.node.flipkick.media.+014+19137
          key_domain_split_regex='(.*)\.\+(.*)\+(.*)$'
          if [[ $key =~ $key_domain_split_regex ]]; then
            key_id=${BASH_REMATCH[3]}
            domain=${BASH_REMATCH[1]}
          fi
          log "found KSK key_id: ${key_id} domain:${domain}"
        else
          continue
        fi
      else
        continue
      fi

      if [[ ! -d "${dsprocess_path}/${view}" ]]; then
        mkdir -p "${dsprocess_path}/${view}"
      fi
      chown root:root "${dsprocess_path}"
      chmod 777 "${dsprocess_path}"

      # if [[ ! -f "${dsprocess_path}/${view}/${domain}.dsprocess" ]]; then
      log "creating dsprocess lock: ${DSPROCESS_PATH}/${view}/${domain}.dsprocess"
      touch "${DSPROCESS_PATH}/${view}/${domain}.dsprocess"
      log "domain: ${domain} view:${view}"
      log "thawing domain: ${domain}"

      config_init

      if [[ $depth -le 1 ]]; then
        "${DIR}/clean" "${domain}" "${view}" "${ip_addr}" "${ns_server}" 60 "${key_id}"
        resclean=$?
        log "result from clean was $?"
        "${DIR}/init" "${domain}" "${view}" "${ip_addr}" "${ns_server}" 60 "${key_id}"
        log "result from init was $?"
        resinit=$?
      fi

      rndc -k "${domain_key}" -c "${domain_conf}" sync -clean "${domain}" in "${view}"
      rndc -k "${domain_key}" -c "${domain_conf}" flush
      rndc -k "${domain_key}" -c "${domain_conf}" thaw "${domain}" in "${view}"
      # else
      #   log "domain locked"
      # fi
    done
  done
  log "monitor (initialise keys) terminating on PID:$$"
  exit 0
fi

# stop repeated additions via nsupdate as views are handled in the same scope as the main process
if [[ $1 == '--monitor-external' ]]; then
  log "monitor running on $$ for external CDS/KSK publish events"

  if [[ -f "${DIR}/lib.sh" ]]; then
    # shellcheck disable=SC1091
    echo "...loading lib ${DIR}/lib.sh"
    . "${DIR}/lib.sh"
  fi

  # shellcheck disable=SC2153
  if [[ -f "/etc/cme/dnssec-monitor.env" ]]; then
    echo "...loading /etc/cme/dnssec-monitor.env"
    # shellcheck disable=SC1091
    . "/etc/cme/dnssec-monitor.env"
  fi
  readarray -td: views < <(printf '%s' "$VIEWS")

  function trap_exit() {
    log "terminating external CDS check on PID:$$"
    exit 0
  }

  while IFS= read -r line; do
    readarray -td: ext_dns <<<"$line"
    ds="$(dig "@${NS_SERVER}" +short "${ext_dns[0]}" DS)"
    if [[ "$ds" != "${ext_dns[1]}" ]]; then
      "${DIR}/update.sh" "${ext_dns[0]}"
    fi
  done <"$EXTERNAL_DOMAIN_LIST"

  trap "trap_exit" SIGINT SIGHUP 15

  shopt -s extglob
  while (true); do
    if [[ -n $retry && $retry -gt $(date +%s) ]]; then
      sleep 5
      continue
    fi

    start=$(date +%s)
    retry=$((start + EXTERNAL_REFRESH))
    for dsprocess in "${DSPROCESS_PATH}/"*.dsprocess; do
      if [ ! -f "$dsprocess" ]; then
        sleep 5
        continue
      fi
      if [[ $(date -r "$dsprocess" "+%s") -lt $(($(date +%s) - 60)) ]]; then
        locked_domain=$(basename "$dsprocess")
        log "removing dsprocess lock for ${locked_domain//\.dsprocess/}"
        rm "$dsprocess"
      fi
    done
    sleep 5
  done
fi

function trap_exit() {
  if [[ -n $monitor_pid && -n $(ps -p "$monitor_pid") ]]; then
    log "monitor terminating on PID:$monitor_pid"
    kill -1 "$monitor_pid"
    wait "$monitor_pid"
  fi
  if [[ -n $tail_pid && -n $(ps -p "$tail_pid") ]]; then
    kill -1 "$tail_pid"
    wait "$tail_pid"
  fi
  exit 0
}

if [[ $# -eq 0 ]]; then
  log "monitor running on $$ for CDS/KSK publish events"
  # if [[ $CME_DNSSEC_MONITOR_DEBUG -eq 1 ]]; then
  # print config
  log "WORKING_DIR ............ : ${DIR}"
  log "DATA_PATH .............. : ${DATA_PATH}"
  log "DSPROCESS_PATH ......... : ${DSPROCESS_PATH}"
  log "CONF_PATH .............. : ${CONF_PATH}"
  log "BIND_LOG_PATH .......... : ${BIND_LOG_PATH}"
  log "KEY_PATH ............... : ${KEY_PATH}"
  log "CME_DNSSEC_MONITOR_DEBUG : ${CME_DNSSEC_MONITOR_DEBUG}"
  log "LOGGER_FLAGS ........... : ${LOGGER_FLAGS}"
  log "MONITORING BIND LOGS ... : ${files}"
  log "VIEWS .................. : ${views[*]}"

  declare ip_addr
  declare ns_server
  declare domain
  declare ttl
  declare view
  declare record

  trap "trap_exit" SIGINT SIGHUP 15

  LOGGER_FLAGS=${LOGGER_FLAGS} "${DIR}/monitor" --init &

  LOGGER_FLAGS=${LOGGER_FLAGS} "${DIR}/monitor" --clean &

  # run once and add all DS keys, regardless
  #LOGGER_FLAGS=${LOGGER_FLAGS} "${DIR}/monitor" --init &

  declare -i monitor_pid=$!
  declare -i key_found=0

  # main monitoring/update
  (
    log "monitoring log"
    # if [[ -f "${DIR}/lib.sh" ]]; then
    #   # shellcheck disable=SC1091
    #   . "${DIR}/lib.sh"
    # fi
    # log "monitoring logs ${files}"
    # shellcheck disable=SC2086
    tail -n0 -f $files | stdbuf -oL grep '.*' |
      while IFS= read -r line; do
        # example
        # Nov 11 17:25:06 ninja named[3260031]: 11-Nov-2022 17:25:06.474 general: notice: zone prod.node.flipkick.media/IN/internals-master (signed): checkds: empty DS response from 192.168.88.254#53
        if grep -P '.*checkds: empty DS response.*' <<<"$line"; then
          # @todo check to make sure we init a new key on domains we have control of.
          log "trigger line: $line"
          # capture view from message
          if [[ $line =~ $empty_ds_regex ]]; then
            domain=${BASH_REMATCH[1]}
            view=${BASH_REMATCH[2]}

            declare ip_addr
            declare ns_server
            declare iface
            declare key_name
            declare key

            config_init "$view"

            # check if domain is next to a tld
            domain_parent=$(parent_domain $domain)
            depth=$(tld_depth $domain_parent)
            declare depth=$(tld_depth "${domain_parent}")

            if [[ $depth -le 1 ]]; then
              log "aborting can't update: ${domain} is TLD"
            elif [[ $depth -gt 1 ]]; then
              log ""
              log ""
              log ""
              log "handling empty DS response"
              # log "depth .......: ${depth}"
              # log "domain ......: ${domain}"
              # log "view_var ....: ${view_var}"
              # log "view.........: ${view}"
              # log "key_var .....: ${key_var}"
              # log "key_name ....: ${key_name}"
              # log "key_name_var : ${key_name_var}"
              # log "key .........: ${key}"
              # log "iface_var ...: ${iface_var}"
              # log "iface_name...: ${iface_name}"
              # log "iface........: ${iface}"
              # log "ip_addr .....: ${ip_addr}"
              # log "ns_server....: ${ns_server}"
              # log "CONF_PATH....: ${CONF_PATH}"
              "${DIR}/clean" "${domain}" "${view}" "${ip_addr}" "${ns_server}" 60 "${key_id}"
              log "result from clean was $?"
              "${DIR}/init" "${domain}" "${view}" "${ip_addr}" "${ns_server}" 60 "${key_id}"
              log "result from init was $?"
            fi
          fi
        fi

        # example
        # line='04-Jun-2022 07:12:02.164 dnssec: info: DNSKEY node.flipkick.media/ECDSAP384SHA384/29885 (KSK) is now published'
        if grep -P '.*info: DNSKEY.*\(KSK\).*published.*' <<<"$line"; then
          log ""
          log ""
          log ""
          key_found=0
          domain=$(awk '{print $6}' <<<"${line//\// }")
          A="00000"
          B="$(awk '{print $8}' <<<"${line//\// }")"
          #key_id="$(echo "${A:0:-${#B}}$B")"
          key_id="${A:0:-${#B}}$B"

          declare sleep_time=1
          declare -i max_sleep=20
          declare curr_sleep=0

          while [[ $key_found -eq 0 && $curr_sleep -lt $max_sleep ]]; do
            if [[ ${max_sleep} -lt ${curr_sleep} ]]; then
              log "...cant wait any longer for key: ${key_file}"
              break
            fi

            for view in "${views[@]}"; do
              key_file="/var/cache/bind/keys/${view}/K${domain}.+014+${key_id}.key"
              if [[ -f "${key_file}" ]]; then
                key_found=1
                log "KSK Published!"
                log "domain:${domain}"
                log "key_id:${key_id}"
                log "view:${view}"
                log "key_file: ${key_file}"
                # if [[ ! -f "${DSPROCESS_PATH}/${view}/${domain}.dsprocess" ]]; then
                #   touch "${DSPROCESS_PATH}/${view}/${domain}.dsprocess"
                log "running: ${DIR}/add"
                if [[ -f "${DIR}/add" ]]; then
                  "${DIR}/add" "${domain}" "${view}" "${ip_addr}" "${ns_server}" 60 "${key_id}"
                  #                \$domain \$view \$ip_addr \$ns_server \$ttl \$key_id"
                  log "result from add was $?"
                else
                  log "can't find cmd: ${DIR}/add"
                fi
                break 2
                # fi
              fi
            done
            curr_sleep=$(expr $curr_sleep + $sleep_time)
            sleep 1
          done

          if [[ $key_found -eq 0 ]]; then
            log "KSK Published but key was not found in any view! domain:${domain} view:${view} key:K${domain}.+014+${key_id}.key"
          fi
        fi
        # example
        # line='04-Jun-2022 12:00:07.686 general: info: CDS for key node.flipkick.media/ECDSAP384SHA384/16073 is now published'
        if grep -P '.*info: CDS for key.*published.*' <<<"$line"; then
          log ""
          log ""
          log "$line"
          key_found=0
          domain=$(awk '{print $8}' <<<"${line//\// }")
          A="00000"
          B="$(awk '{print $10}' <<<"${line//\// }")"
          key_id="${A:0:-${#B}}$B"
          declare sleep_time=1
          declare -i max_sleep=20
          declare curr_sleep=0
          while [[ $key_found -eq 0 && $curr_sleep -lt $max_sleep ]]; do
            if [[ ${max_sleep} -lt ${curr_sleep} ]]; then
              log "...cant wait any longer for key: ${key_file}"
              break
            fi

            for view in "${views[@]}"; do
              key_file="/var/cache/bind/keys/${view}/K${domain}.+014+${key_id}.key"
              if [[ -f "${key_file}" ]]; then
                key_found=1
                log "CDS Published!"
                log "domain:${domain}"
                log "key_id:${key_id}"
                log "view:${view}"
                log "key_file: ${key_file}"
                # if [[ ! -f "${DSPROCESS_PATH}/${view}/${domain}.dsprocess" ]]; then
                #   touch "${DSPROCESS_PATH}/${view}/${domain}.dsprocess"

                log "running: ${DIR}/add"
                "${DIR}/update" "${domain}" "${view}" "${ip_addr}" "${ns_server}" 60 "${key_id}"
                log "result from update was $?"
                break 2
                # fi
              fi
            done
            curr_sleep=$(expr $curr_sleep + $sleep_time)
            sleep 1
          done
          if [[ $key_found -eq 0 ]]; then
            log "CDS Published but key was not found in any view! domain:${domain} view:${view} key:K${domain}.+014+${key_id}.key"
          fi
        fi
      done
  ) &
  tail_pid=$!
  wait $tail_pid
fi
exit 0
